https://discountry.github.io/react/docs/hello-world.html  中文文档
https://facebook.github.io/react/docs/hello-world.html    英文文档
http://www.8dou5che.com/2017/05/11/vue-lazyload/          v-lazyLoad中文文档
npm view jquery versions 查看所有版本
npm install jquery@2.2.3 安装指定版本
https://doc.webpack-china.org/configuration  webpack
http://www.cnblogs.com/liyunhua/p/4529086.html   JS一些性能问题
=========================================================
*****     @是v-on的缩写       ********
用在普通元素上时，只能监听 原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。

*************************************
=========================================================
<head-top signin-up='home'>
            <span slot='logo' class="head_logo"  @click="reload">ele.me</span>
 </head-top>
当上面的加载下面的模板的时候 ，slot指定名字标签将要加载对应替换模板的所有元素,当元素里面不添加任何
指定名字的话，默认替换自义定标签中全部的内容
<header id='head_top'>
 <slot name='logo'></slot>
</div>

==========================================================
 <ul class="citylistul clear">
                <router-link  tag="li" v-for="item in hotcity" :to="'/city/' + item.id" :key="item.id">
                    {{item.name}}
                </router-link>  
            </ul>
 可以不用a来表示  用tag表示标签  路由的话会自动push进去


this.$router.push({path:'/msite', query:{geohash}})
==========================================================
   
query是带参数查询，想当于  xxx.xxx.login?geohash=geohash

=======================================================
****   一般循环的时候都会增加单独的keyk来绑定  有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。
****   一般都是结合v-for来渲染 
<li v-for="item in items" :key="item.id">...</li> 


=======================================================
****   如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素; 如果用在子组件上，引用就指向组件实例:
	<div class="recommend" ref="recommend"></div>
	this.$refs.recommend.style.bottom = bottom
		

=======================================================
****  父组件传递参数给子组件的一种默认写法
 <song-list :title ="title" :name="name" @select="selectItem"></song-list> 

****
  props: {
      title: {
        type: String,
        default: '正在载入...'
      },
      name{
        type: Number,
        default: 1
      }
    }

=======================================================
// 命名的路由  参数
router.push({ name: 'user', params: { userId: 123 }})

// 对象
this.$router.push({path: '/login?url=' + this.$route.path});


Vue.nextTick( fn() )  这个方法是在dom渲染完毕的时候的回调，可以对dom进行操作 然create是不可以的

===================================================================
**********    vuex数据驱动       ***************
	import {mapState , mapActions} from 'vuex'
computed : {
			...mapState([
				'recommendImageList',
				'recommendList'
			])
			
		} 数据中获取 （mapState）
	
methods : {
	...mapActions([
				'saveRecommendImageList',
				'saveRecommendList'
            ])

}
 设置数据，数据驱动更新（mapActions）
	      
	
===================================================================
****       针对better-scroll的插件，博客 		****
  
http://blog.csdn.net/sinat_17775997/article/details/72841002 

https://ustbhuangyi.github.io/better-scroll/doc/options.html#freescroll

图片如果没加载肯定没发获取高度，这个插件实例化肯定有问题，所以如果想解决这个问题，
< img src="" @load="imgLoad"> 在其中添加一个load事件，在加载一个flg，防止后面图片太多，
浪费资源一直实例化的问题

===================================================================
********    	computed     	********
computed: {
     vincentwan() {
		console.log('wanxiong~~~~~~~~~~~~~wanxiong')
		return 'wanxiong'
	},
     listData() {
		
		return [1 , 2 , 3 , 4]
	}
},
-------------------------
<p>{{vincentwan}}</p>
<p v-for=" item in listData ">{{ item  }}</p>

------------------------
此时他是一个属性，不在是一个方法   她返回的也是data数据中的一部分

==================================================================
*************    watch监听方法     **********************
var vm = new Vue({
	     el: '#app',
             data: {
                 firstName: 'a',
                 lastName: 'fei',
                 fullName: 'a fei'
             },
             watch: {
                 firstName: function (newVal, oldVal) {
                     this.fullName = newVal + ' ' + this.lastName
                 },
                 lastName: function (val) {
                     this.fullName = this.firstName + ' ' + val
                 }
             }
}
--------------
 <div id="watch">
         firstName:<input type="text" name="li"  v-model="firstName">
         <br>
         lastName:<input type="text" name="fei"  v-model="lastName">
         <p>fullName: {{fullName}}</p>
 </div>
-----------------  主要是监听设定的值的变化

==================================================================
******   动画    *******************

<template>
	<transition name="slide">
		<div>
			<div>singer子页面</div>
		</div>
	</transition>
</template>

*******************************************************
1 ***** v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。
2 ***** v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。
3 ***** v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。
4 ***** v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。
.search-item
      height: 40px
      &.list-enter-active, &.list-leave-active
        transition: all 0.1s
      &.list-enter, &.list-leave-to
        height: 0
-------------------------------------
.slide-enter-active, .slide-leave-active{
	    transition: all 0.3s
	}

.slide-enter, .slide-leave-to{
	    transform: translate3d(100%, 0, 0)
	}
v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition/animation 完成之后移除。
v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在 transition/animation 完成之后移除。


<transition name="palyer"
	@enter="enter"
	@after-enter="afterEnter"
	@leave="leave"
	@after-leave="afterLeave"
>
动画自带的钩子函数
methods:{
	enter( el ,done){
	}
}
在对应的methods添加对应的方法即可 



===================================================================
****      nextTick对应节点加载完毕  ***********
currentSong() {
			//等加音频加载完毕再来播放
			/*this.$nextTick(() => {
				this.$refs.audio.play()	
			})*/
},

===================================================================